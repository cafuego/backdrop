<?php
/**
 * Classes for extending pager queries.
 */

/**
 * Query extender for pager queries.
 *
 * This is the "default" pager mechanism.  It creates a paged query with a fixed
 * number of entries per page.
 */
class PagerDefault extends SelectQueryExtender {

  /**
   * The highest element we've autogenerated so far.
   *
   * @var int
   */
  static $maxElement = 0;

  /**
   * The number of elements per page to allow.
   *
   * @var int
   */
  protected $limit = 10;

  /**
   * The unique ID of this pager on this page.
   *
   * @var int
   */
  protected $element = NULL;

  /**
   * The count query that will be used for this pager.
   *
   * @var SelectQueryInterface
   */
  protected $customCountQuery = FALSE;

  public function __construct(SelectQueryInterface $query, DatabaseConnection $connection) {
    parent::__construct($query, $connection);

    // Add pager tag. Do this here to ensure that it is always added before
    // preExecute() is called.
    $this->addTag('pager');
  }

  /**
   * Override the execute method.
   *
   * Before we run the query, we need to add pager-based range() instructions
   * to it.
   */
  public function execute() {

    // Add convenience tag to mark that this is an extended query. We have to
    // do this in the constructor to ensure that it is set before preExecute()
    // gets called.
    if (!$this->preExecute($this)) {
      return NULL;
    }

    // A NULL limit is the "kill switch" for pager queries.
    if (empty($this->limit)) {
      return;
    }
    $this->ensureElement();

    // Extract the current page from the request.
    $page = pager_find_page($this->element);

    // Rather than rely on the countQuery, add a query hint to prepare for a
    // FOUND_ROWS() call a bit later on. That means we don't need to load the
    // entire table index twice, which should see a nice speed increase when
    // paging through large tables, esepecially on InnoDB.
    $this->query->setHints('SQL_CALC_FOUND_ROWS');

    // We usually calculate the total number of pages as ceil(items / limit) but
    // now that we don't run a countQuery, we don't know the total number of rows
    // before running the pager_query. For now we assume that the total items is
    // the current page number multiplied by the limit. We recalculate when we
    // know the correct total number.
    $this->range($page * $this->limit, $this->limit);

    // Now that we've added our pager-based range instructions, run the query
    // normally.
    $result = $this->query->execute();

    // And now we can fetch the total number of results, had there not been
    // a range.
    $total_items = $this->connection->query('SELECT FOUND_ROWS()')->fetchField();

    // This does unfortunately mean that a user can override the page variable
    // in the query string and end up with an empty pager. Previously this would
    // make this default to the last page. We can emulate this behaviour by
    // checking the total number of rows returned and re-run an adjusted query
    // in that case.
    //
    // What we do now is check if our query range was out of bounds, which can
    // happen if the user manually overrode the page variable in the query
    // string. If no rows were returned and if we're not looking at the first
    // page of this pager, adjust the range to return the last page of results
    // only, just as we would normally do.
    if (!empty($page) && (($page * $this->limit) > $total_items)) {
      // Calculate the new range and re-run the pager query to return the last
      // page of results.
      $page_max = ceil($total_items / $this->limit) - 1;
      $this->range($page_max * $this->limit, $this->limit);
      // No need to re-count all rows, so remove the hint.
      $this->query->setHints('');
      $result = $this->query->execute();
    }

    // Initialize pager variables for the current pager.
    pager_default_initialize($total_items, $this->limit, $this->element);

    // Return the query results.
    return $result;
  }

  /**
   * Ensure that there is an element associated with this query.
   *
   * If an element was not specified previously, then the value of the
   * $maxElement counter is taken, after which the counter is incremented.
   *
   * After running this method, access $this->element to get the element for this
   * query.
   */
  protected function ensureElement() {
    if (!isset($this->element)) {
      $this->element = self::$maxElement++;
    }
  }

  /**
   * Specify the count query object to use for this pager.
   *
   * You will rarely need to specify a count query directly.  If not specified,
   * one is generated off of the pager query itself.
   *
   * @param SelectQueryInterface $query
   *   The count query object.  It must return a single row with a single column,
   *   which is the total number of records.
   */
  public function setCountQuery(SelectQueryInterface $query) {
    $this->customCountQuery = $query;
  }

  /**
   * Retrieve the count query for this pager.
   *
   * The count query may be specified manually or, by default, taken from the
   * query we are extending.
   *
   * @return SelectQueryInterface
   *   A count query object.
   */
  public function getCountQuery() {
    if ($this->customCountQuery) {
      return $this->customCountQuery;
    }
    else {
      return $this->query->countQuery();
    }
  }

  /**
   * Specify the maximum number of elements per page for this query.
   *
   * The default if not specified is 10 items per page.
   *
   * @param $limit
   *   An integer specifying the number of elements per page.  If passed a false
   *   value (FALSE, 0, NULL), the pager is disabled.
   */
  public function limit($limit = 10) {
    $this->limit = $limit;
    return $this;
  }

  /**
   * Specify the element ID for this pager query.
   *
   * The element is used to differentiate different pager queries on the same
   * page so that they may be operated independently.  If you do not specify an
   * element, every pager query on the page will get a unique element.  If for
   * whatever reason you want to explicitly define an element for a given query,
   * you may do so here.
   *
   * Setting the element here also increments the static $maxElement counter,
   * which is used for determining the $element when there's none specified.
   *
   * Note that no collision detection is done when setting an element ID
   * explicitly, so it is possible for two pagers to end up using the same ID
   * if both are set explicitly.
   *
   * @param $element
   */
  public function element($element) {
    $this->element = $element;
    if ($element >= self::$maxElement) {
      self::$maxElement = $element + 1;
    }
    return $this;
  }
}
